# 前端模块化

### 前端组件化和模块化

- 开发阶段用到的,分工协作,最后结合构建工具合理打包

#### 区别
1. 组件化关注的更多是UI部分,一个标题栏,内容区,确认按钮都可以是个组件,一些组件又可以组成一个弹框组件,跟其他组件组合又是一个新组件,(形象的来说就是一个黑盒子(样式style,结构template,逻辑script(可以调用模块)),拿过来就可以用)
2. 模块化侧重于功能或者数据的封装,一组相关的组件可以定义成一个模块;一个暴露了通用方法的对象可以定义成一个模块;一个全局的JSON配置文件也可以定义成一个模块(一个组件或者多个组件构成的带有一定功能的比如窗户,床)


# 重点说模块化
- **目的**: 解决传统多人协作编程中的两大问题:**命名冲突**和**js之间的依赖**



## SeaJs库
作用: 
- 解决两个问题
- 提升代码可维护性

**步骤**:

1. `index.html`

	```javascript
	<script src='sea.js'></script>//引入`seajs`库
	<script>
		/*use方法参数说明: 
			1. js模块地址,注意,地址不能写成('js/module1.js'),因为这样是相对于seajs默认的根目录(sea.js这个文件的路径)
			2. 回调函数参数ex指的是module文件暴露出来的对象exports
		*/
		seajs.use('./js/module1.js',function(ex) {
			ex.fn1();
		})
		seajs.use('./js/module2.js',function(ex) {
			ex.fn1();//即使命名跟上边的一样,也不会冲突
		})
		
	</script>
	```

2. `module1.js`	
	
	```javascript
	//1.定义模块
	define(function(require,exports,module/*这三个参数的名字是固定的*/){//解决了命名冲突
	/*
	参数说明: 
		exports: 对外提供的接口,暴露出去的对象
		require: 一个方法,用来声明依赖,获取到其他某一个组件里的变量
	*/
	
		function fn1() {
			....
		}
		exports.fn1 = fn1;//这样就能在外面通过exports.fn1()调用了
	})
	```
3. ***处理依赖(组件间的通信):***
	`module2.js`

	```javascript
	/*上线版本define要多出两个参数:
		1. 当前模块的id
		2. 依赖模块id的数组
	*/
	define('./module2.js',['./module3.js'],function(require,exports,module){
	//想要使用module3.js模块定义的a
		/*当module3是普通js文件
		require('./module3.js');
		*/
		//当module3也是一个模块时,require('./xx')返回的就是该模块的exports对象,所以该怎么用怎么用
		var a = require('./module3.js').a;
		function fn1() {
			alert(a)//想要使用module3.js模块定义的a
		}
		exports.fn1 = fn1;
	})
	```
	`module3.js`

	```javascript
	//var a = 1;//普通的js文件模块
	define(function(exports,require, module){
		var a = 1;
		exports.a = a;
	})//sea下的模块
	```
	
	
	
### 关于CMD,AMD,CommonJS
1. CommonJS
	- 服务端模块化是需要一些规范的
	- 随着nodejs的出现,js也可以写后端程序,而`CommonJS`这种**服务端js模块化规范**应运而生

2. CMD & AMD
	- 随着前后端的分离,前端(浏览器端)工作量日益加大,这时就需要分工协作,也就需要到了模块化,所以浏览器端js模块化也需要一个规范
	- 关于**浏览器端js模块化规范**,形成了两大阵营:
		1. AMD:
			- 完全脱离commonJS的影子,完全创新的一个规范
			- `requireJS`库遵循了AMD

		2. CMD: 
			- 参照commonJS规范形成的浏览器端js模块规范
			- 'seaJS'库遵循了CMD

			
			
### 自动化构建工具Gruntjs
开发一个项目需要多人分工协作,就会产生大量的代码文件,最后上线的时候们需要把他们打包,合并,压缩,减少http请求,自动化构建工具就是做这个的

安装流程: 
1. 安装node(内置了npm)
2. npm install -g grunt-cli
3. npm install grunt --save-dev
4. grunt -version


### seajs模块化开发后的合并问题
直接合并会有一个问题,变成一个文件依赖路径找不到了!!!所以真正工作时,define还要有两个参数: 自己的id字符串,依赖文件名数组
		 