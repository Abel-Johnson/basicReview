# 同步和异步的区别?

**同步异步**于**阻塞非阻塞**并没有关系。

- 同步异步主要是事情做完以后，如何进行处理、或者说关注的是一种消息通信机制。
	- 同步的情况下，是由处理消息者自己去等待消息是否被触发；
	- 异步的情况下是由触发机制来通知处理消息者；
	
	> 举例： 比如在上课时，你问老师一个问题，这个问题可能需要花费一点时间去思考，这个时候老师可能：
	> 
	> 思考，思考……，好了，有答案了；
	> 这个问题需要一点时间，你先做点别的，等我想好了，去找你。
	> 第一种就是同步，第二种就是异步。所以同步异步可以说是对被请求方来说的，被请求者使用什么方式来告知处理结果。

- 阻塞非阻塞，主要是对于请求者而言的。
	- 阻塞：发出请求等待结果返回，然后再处理后续的事情；
	- 非阻塞：发出请求不等待结果返回，可以接着做后续的事情；
	
	> 举例，还是上一个例子：
	> 
	> 老师在使用同步思考的时候，你可以静静的等待老师给出答案，也可以边做自己的事情边等待老师的回答，当然这时候你需要时刻去关注老师是否已经想好了，在程序中需要进行轮询了。乀(ˉεˉ乀)
	> 老师使用异步的方式，这个时候老师告诉你可以先去做别的，好了就通知你，那么你可以去做点别的，然后监听事件就行，当然你也可以很轴，我就不做别的！我要一直等着老师“想好了”的事件发生。

***所以同步可以是阻塞的也可以是非阻塞的，异步也是如此。***

> 阻塞非阻塞,异步非异步
>     - 同步&异步是**做事情的方式**:
>         1. 同步: 做完一件事才去做下一件事
>         2. 异步: 两件事同时开始做 
>     - 阻塞&非阻塞是**对待事情产生的结果的方式**:
>         1. 阻塞: 不等到想要的结果我就不走了
>         2. 非阻塞: 有结果我就带走，没结果我带走一个'空结果'(会立马得到一个结果)

--

# js事件执行机制: 
1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
1. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
1. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
1. 主线程不断重复上面的第三步。
