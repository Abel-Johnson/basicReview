1. 变量命名规范: 
    - 由数字(1234..)字母(aBc...)下划线(_)美元符($)组成
    - 开头不能是数字
    - 不能是关键字,保留字
    
2. 属性操作什么时候用`.`什么时候用`[]`?
    - 属性名不符合变量命名规范时用[''], 例如: `style.['background-color']`
    - 属性名是变量时只能用[], 例如: `style.[a]`
    - 普通情况下,两个都可以用, 例如: `style.['background']`,`style.background`
    
3. for跟while区别?

   ```javascript
    var a = 0;
    while(a<3) {
        alert(++a);
    }
    ``` 
    等价于
    
    ```javascript
    var a = 0;
    for(;a<3;) {
        alert(++a);
    }
    ```
    
    for关心执行的语句,while关心判断的条件
4. switch语句的格式: 

    ```javascript
    switch (a) {
        case 1:
            //语句;
            break;
        case 2: 
            //语句;
            break;
        ...
        default:
            //语句;
            break;
    }
    ```
    
    
5. 日期对象
 new Date(参数:可以是排列好的字符串,也可以是一组排列好的年月日参数,也可以是时间戳`时间戳: 1970-1-1 00:00到日期对象的时间差*毫秒数*`,还可以不传参),都会返回相对应的日期对象
    - 方法: (设置函数setxxx()的返回值是对应的时间戳)
        - get/setFullYear()
        - get/setMonth()//从0开始算的,setMonth(1)设置的是二月
        - get/setDate()//设置的话,setDate(0/33)都不会报错,会自动转成上个月或下个月的日期
        - get/setDay()
        - get/setHours()
        - get/setMinutes()
        - get/setSeconds()
        - get/setMilliSeconds()
        - get/setTime()//转换成时间戳
    
    - 关于秒数(sec)转换成是具体的 天 时 分 秒 的方法: 
        1. 首先要清楚: 
            > 1d = 24h = 1440m = 86400s
            > 1h = 60m = 3600s
            > 1m = 60s
            > 1s = 1s
        
        2. 所以: 
            >天: Math.floor(sec/86400)  
            >时: Math.floor(sec%86400/3600)  
            >分:  Math.floor(sec%86400%3600/60)
            >秒: sec%60
     - 自己写一个当前月份日历的思路: 
         1. 获取到当前时间,new Date()   
         2. 这个月有多少天?
             1. 把月份设置成下一个月,
             2. 然后把日期设置成0,就得到了本月的最后一天的日期对象
             3. getDate(),得到本月天数
         3. 月初显示的时候空几格,取决于第一天是星期几
             1. setDate(1)
             2. getDay(),知道了1号是星期几,就可以布局了
         4. 一共生成 星期+天数个方块
             1. 前面的方块是透明的,
             2. 后面的方块内容是`i-week+1`
         
6. 很经典的题目: 无缝滚动(轮播图)  
    **两种**思路: 
    1. 给一串图片末尾添加一张图片,这张图片要跟第一张图片长得一模一样
       - **步骤如下**: 
          - 图片走到最后一张时,瞬间修改整条图片的定位值使第一张代替原来最后一张的位置,由于两张图片长得一样,所以看不出来移动的过程
    2. 全程只有两个小图片容器,开始两个容器里放着第一第二张图片,通过更换里面的img实现轮播
       - **步骤如下**
           1. 先把第二个容器里的图片换成下一张
           2. 整体慢慢运动,使第二个容器里下一张.jpg缓缓出现,动画结束的瞬间,做了两件事
               1. 把第一个容器里src瞬间换成第二个容器里的
               2. 然后瞬间把整体拉一个图片的宽度,使第一个容器里第二张的复制品替换原来第一个容器里第二张的位置
               
7. 字符串方法:(注意,字符串的长度不可以直接修改)  
    `string`: 
    1. str.charAt()/charCodeAt() 
    2. str.indexOf/lastIndexOf(st[,fromInd])   
    2. str.slice(b[,e])/substring(b[,e])
    3. str.substr(b[,l])
    4. str.split([separator][,limit])//返回一个数组
    4. str.toUpperCase/toLowerCase() //一定注意该方法不会改变原字符串,会返回一个新字符串
    5. str.trim/trimLeft/trimRight() 
    6. JSON.parse(JSONString)/JSON.stringify(object)                   

8. Math方法  
    `Math`
    1. Math.random() => 返回一个0~1的随机数(不包括1)
    2. Math.pow(2,3) => 2的3次方
    3. Math.sqrt(9) => 9的开方根

9. Array方法  
    `Array`
    1. arr.pop()/push(一或多个元素)/shift()/unshift(一或多个元素) //这些方法都会**修改原数组**,返回值删除的哪一位/添加后的数组长度
    2. forEach(function(value,index,array){}[,thisArg])//对每一项执行一遍指定的语句,返回值是undefined
    3. arr.sort(function(){return 负数不交换位置,正数交换位置})不传参默认根据字符串Unicode位点进行排序,**会改变**原数组
    4. arr.concat()
    5. arr.reverse()//**会修改**原数组
    6. arr.join([separator])
    7. arr.slice([b[,e]])
    8. arr.splice(s, c[, i1,i2]),**会修改**原数组,返回被删除元素组成的新数组

10. 算法: 
	- 冒泡排序: 
		- 比如一共四个数,
			- 第0(一)轮经过3轮比较把最大的数放到最后
			- 第1(二)轮经过2轮比较吧第二大的放到倒数第二位
			- 第2(三)轮经过1轮比较结束

		- 所以就是一个for循环嵌套,总共进行(length-1)大轮比较,每大轮有(length-1-i)小轮比较
		
		
		```javascript
		function sort(arr) {
			for (var i = 0; i < arr.length-1; i++) {
			 	var noNeedCompare = true;//优化,定义一个开关
			 	for (var j = 0; j < arr.length-1-i; j++) {
					if (arr[j] > arr[j+1]) {
						var temp = 0;
						temp = arr[j];
						arr[j] = arr[j+1];
						arr[j+1] = temp;
						noNeedCompare = false;//只要有一组比较时前一个数比后一个数大,就会修改这个开关,也即需要进行下一大轮的比较
					}
				}
				if (noNeedCompare) break;//只要每一组比较时前一个数都比后一个数小,就说明不需要进行下一大轮的比较了,直接break就好
	
			}
			return arr;
		}
		```
	- 快速排序: 

	思路: 
	
	1. 随便找一个值temp
	2. 遍历数组,把比temp小的值放到他左边数组,大的值放到他右边数组
	3. 对左边数组和右边数组执行同样的操作
	4. 返回左边数组拼接temp拼接右边数组的数组

	```javascript
	function sort(arr) {
    	if(arr.length <= 1) return arr;
    	var temp = arr.splice(0,1)[0];//splice方法得到的是一个数组,虽然数字可以和数组直接比较(隐式类型转换成Number类型),但是最好还是取出来再比较
    	console.log(temp);
    	var LArr = [];
    	var RArr = [];

    	for (var i = 0; i < arr.length; i++) {
    		if(arr[i]<temp){
    			LArr.push(arr[i]);
    		} else {
    			RArr.push(arr[i]);
    		}
    	}
    	LArr = sort(LArr);
    	RArr = sort(RArr);
    	arrT = LArr.concat(temp,RArr);
    	return arrT;
    }
	```
		
11. 注意的几点: 

	```javascript
	var box = document.getElementById("box");
	a1.onclick = function() {
		alert(1);
	}
	box.innerHTML += "<div></div>";
	```
	**!** **重写父级innerHTML后,子元素的事件处理函数就失效了**
		
	```javascript	
	for(var i= 0,j = 0;i<6,j<10;i++,j++) {
		k = i+j;
	}
	console.log(k);
	```	
	**!** **逗号运算符返回位于最后的一项**
		
	```javascript
	var str = "asdf";
	str.length = 2;
	console.log(str);
	```
	**!** **字符串长度是不可修改的**
		
12. DOM(节点node部分)

	含义|node.nodeType|node.nodeName|获取方法
	---|----|---|---
	元素节点|1|DIV/SPAN...|
	属性节点|2|id/class/style..|box.attributes[0/1/2..]
	文本节点|3| #text|
	注释节点|8|#comment|
	文档节点|9|#document|
	
	
	方法名node.xx|说明
	---|---
	*获取节点*|
	~~`node.childNodes`~~|获取到**所有**的一级**子节点**~~**不常用**
	`node.children`|获取到**所有**的一级**元素节点**
	`node.parentNode`|获取到一级父**元素节点**
	`node.PreviousElementSibling`|
	`node.NextElementSibling`|
	`node.firstElementChild`|
	`node.lastElementChild`|
	|
	`node.offsetParent`|获取到定位父级,如果没有,就是**body**
	|
	`tableNode`.`tHead/tFoot/tBodies[0]`.`rows[0]`.`cells[0]`|表格DOM方法
	`formNode.name属性值`|表单DOM方法,可以直接获取到对应的元素,一些方法:onchange/oninput/onsubmit/onreset
	*获取距离*|
	`node.offsetLeft/Top`|获取到定位父级的距离
	`node.getBoundingClientRect()`|相对于可视窗口的距离详情(对象)
	`node.getAttribute(attr)`|用来获取元素行间自定义属性(自带的直接通过./[]就可以获取,比如id),获取不到是null
	`node.setAttrbute(attr,value)`|
	`node.removeAttribute(attr)`|
	*操作节点*|
	`document.createElement(tagName)`|创建元素
	`父节点.append/remove/replaceChild(node)`|添加到末尾/删除/替换
	`父节点.insertBefore(把aNode,放到bNode前面)`|添加到指定子节点前面
	`node.cloneNode(boolean(是否深度克隆))`|克隆节点

	
13. 图片`懒加载`原理:
	1. 预先把图片src写在`_src`属性上,`src`属性留空
	2. `window.scroll`时,`图片距离可视窗口top距离`<`窗口高度时`(图片露出来了),把`_src`的值赋给`src`  
		**核心代码:**
		 
		```javascript
		if(imgs[i].getBoundingClientRect().top < document.documentElement.clientHeight-200)
		{
			imgs[i].setAttribute("src",imgs[i].getAttribute("_src"))
		}
		```
14. 题目：找字符串中的所有“ab”的位置和数量

	```javascript
	var str = "abcabcabcabcabcabda";
	var res = [];
	for (var i = 0; i < str.length; i++) {
		//方法一:
		// var index = str.indexOf('ab',i);
		// if (index !== -1) {
		// 	i = index;
		// 	res.push(index)
		// }
	
		//方法二:
		// i = str.indexOf('ab', i);
		// if (i === -1) break;
		// res.push(i);
	}
	console.log(res)	
	```

15. BOM

	方法名|用法
	---|---
	open|window.open(['`url`',`'\_blank/\_self/frameName`',"`width=300px,height=100px`"])|
	close|window.close()/a=window.open();a.close()
	属性: 
	window.navigator.userAgent|