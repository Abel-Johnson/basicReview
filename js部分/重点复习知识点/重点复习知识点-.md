# 重点复习知识点:
 
1. 面向对象,组件封装(登录框,拖拽)(饿了么eleme)
	- 包装对象: 
		- 引入问题: 基本类型为什么会有方法,他们又不是对象? 
		- 基本类型String Number Boolean都会有一个对应的包装对象(null和undefined没有)
		- `var str = new String();`所以是个对象,就可以有属性和方法
		- `var str = "xxx"`一开始是个字符串,没有属性和方法,但是当他调用charAt之类的方法时,会在内部新建一个对应的包装对象实例,然后在实例上调用方法或者查询属性,然后销毁掉包装对象实例,依然返回字面量类型(也就是基本类型)
	- Tips: 关于语句块和表达式: 
		- {}+[]//{};+[]==>0(这里的加号并不是代表加法的二元运算符,而是一个一元运算符,作用是将它后面的操作数转换成数字,和Number()函数完全一样.)
		- []+{}//""+"[object Object]"
		- console.log({}+[])//"[object Object]"+""
		- {}+2//2
		- 2+{}//2[object Object]
		- +{}//NaN
		- {}[0]//[0]
		- true+1 //返回2，布尔型转化为了数字;
		- 对于不同类型的对象，js定义了多个版本的 toString 和 valueOf 方法
			toString:
			（1）普通对象，返回 "[object Object]";
			（2）数组，返回数组元素之间添加逗号合并成的字符串;
			（3）函数，返回函数的定义式的字符串;
			（4）日期对象，返回一个可读的日期和时间字符串;
			（5）正则，返回其字面量表达式构成的字符串;
			valueOf:
			（1）日期对象，返回自1970年1月1日到现在的毫秒数;
			（2）其它均返回对象本身;
		
		> [] + 1 // '1'，先调用ToPrimitive，空数组执行valueOf得到this，不是原始值，执行toString，得到“”，“”+1为 ‘1’;
		> {} + 1 //这里有两种情况，1、F12在控制台中直接运行，则{}被解释成了一个空的代码块而被忽略，所以得到1；2、如果alert({}+1)就是常规的{}+1，{}也是执行toString得到"[object Object]",与1拼接后得“[object Object]1”;
		> var now = new Date() 中，由于也是调用ToPrimitive，但是里面有个偏好值的设置，date对象会被设置成string，所以date对象会先执行toString，返回了字符串（属于原始值），所以就会形成字符串拼接得到字符串。

	判断类型的方法: 
		- typeof(最差,数组和对象都分不开)
		- constructor/instanceof(比如跨iframe验证时会失效)
		- toString(最好的方法,通过返回的字符串判断,格式: Object.prototype.toString(xxx) ==> [object Object/Array/Number.....])
	
	方法也是对象,为什么可以直接复制而不用考虑改变复制函数对原函数的影响?因为仔细想想其实可以知道,对象中的问题是因为两个变量指向同一个地址,而修改其中一个必然会把修改同步到另一个上,但是函数是不存在所谓的修改的,他只会重新赋值,就好像: 
	
	```JavaScript
		var a = {};
		var b = a;
		
		b.attr = 1;//修改
		console.log(a)//会发现a也有这个属性了
		//但是,如果是这样呢?
		b = {attr: 1}
		console.log(a)//会发现a没有改变,是因为b做的是重新赋值,他指向了一个新的地址,与a就失去了联系,所以二者互不影响
			
	```
	
	
	
	js实现继承的几种方式,看`几种继承.html`
	

8. 数组去重(多种方法),看`数组去重.html`
12. canvas svg区别,绘制10000个圆用哪个
> 	Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。
> 	**SVG**
> 	1. SVG 是一种使用 XML 描述 2D 图形的语言。
> 	2. SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。
> 	3. 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
> 	**Canvas**
> 	1. Canvas 通过 JavaScript 来绘制 2D 图形。
> 	2. Canvas 是逐像素进行渲染的。
> 	3. 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。
> 	
> 	**Canvas 与 SVG 的比较**
> 	下表列出了 canvas 与 SVG 之间的一些不同之处。
> 	
> 	- Canvas
> 	
> 		1. 依赖分辨率
> 		1. 不支持事件处理器
> 		1. 弱的文本渲染能力
> 		1. 能够以 .png 或 .jpg 格式保存结果图像
> 		1. 最适合图像密集型的游戏，其中的许多对象会被频繁重绘
> 	
> 	- SVG
> 		1. 不依赖分辨率
> 		1. 支持事件处理器
> 		1. 最适合带有大型渲染区域的应用程序（比如谷歌地图）
> 		1. 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
> 		1. 不适合游戏应用


20. 前后端交互: ajax/jsonp
4. 复习常见的css布局题(圣杯布局,绝对居中)
21. css运动(听网上课)
14. 弹性盒模型
7. cookie/sessionStrorage/LocalStorage(存在电脑哪个地方?)
17. 正则表达式
16. 字符串方法,数组方法(each/foreach之类的)
18. 事件: 阻止默认事件,阻止默认行为
19. 各种尺寸的联系与区别
2. json的适用情况
15. ES6新增语法

6. 算法: 冒泡/快速排序...
7. 清浮动,bfc方法

1. bootstrap(栅格化布局)
3. vue复习(主要TODO),比较另两个框架
11. 单元测试
19. 重构&回流
21. 最后补一补Node.js/webpack/....
13. 熟悉简历里的项目,以及用到的技术